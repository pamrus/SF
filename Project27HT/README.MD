# Модуль 27. Многопоточная работа с данными 
# 27.7. Итоговое задание

Задача

Добавьте в ваш проект чата логгирование сообщений от других участников чата и своих сообщений.

Для этого напишите класс Logger, через который будет проходить вся работа с файлом логов. Сохраняйте сообщения в файл на диске, 
можете назвать его log.txt. При создании объекта логгера должно производиться открытие файла, а при его разрушении — закрытие файла (концепт RAII).

Реализуйте в классе два метода:
	запись строки логов в файл;
    чтение одной строки из файла.
	
Конечно же, запись и чтение должны быть потокобезопасными — при одновременном вызове нескольких потоков с записью в файл и чтением из файла, 
не должно происходить взаимоблокировок и гонок данных.

Не забывайте про принципы инкапсуляции: код, пользующийся вашими методами чтения и записи, не должен знать про многопоточность.



## Отличия от версии модуля 25:

Все отличия ограничиваются созданием класса Logger и добавлением экземпляров класса *Logger* в структуру классов *Boost_Asio_server* и *Boost_Asio_client* (`private: std::shared_ptr<Logger> _logger`). В текущей логике чата полезно логгирование сообщений о статусе подключений, регистрации, входа и передаваемых сообщениях. В связи с чем, в основные методы классов *Boost_Asio_server* и *Boost_Asio_client* были добавлены команды вида: `*_logger << "MSG:NEW <" + chatUsers->getIdByLogin(_login) + "> -> <" + chatUsers->getIdByLogin(msgReceiver) + "> : msgText";`. 

Осталось множество незащищенных критических секций в алгоритмах работы с базой данных: чтение и запись в таблицы сообщений и пользователей осуществляется в разных потоках, создаваемых для каждого клиента при подключении, и может происходить одновременно. Но эти исправления требуют времени и выходят за рамки задачи, поэтому пока не реализованы. Таким образом, изменения в логике работы клиента и сервера, в работе с сетью и с базой данных отсутствуют.


## Описание класса Logger:

Класс построчного чтения/записи текстовых файлов с временными метками.
Открытие файла в режиме *read+write(append)* осуществляется (в закрытой функции *init*) при первом обращении к файлу (использован *std::call_once*).
Количество записанных строк запрашивается функцией *getLinesCount*, после её вызова количество может только увеличиться.
Чтение строки по индексу осуществляется функцией *readNthLine* (индексация с нуля), при её отсутствии возвращается пустая строка.
Добавление новой строки в конец файла осуществляется оператором *<<*.
Извлечение строк из файла не поддерживается. Все критические секции защищены внутренним мьютексом.
Закрытие файла происходит при вызове деструктора класса.
Копирование экземпляров класса запрещено путём наследования от *boost::noncopyable*. Для использования в нескольких потоках можно применять *std::shared_ptr<Logger>*.

## Пример использования:
>{
>	Logger logger("log.txt");
>	logger << "TestStr1";
>	logger << "TestStr2";
>}
>{
>	Logger logger("log.txt");
>	logger << "TestStr3";
>	logger << "TestStr4";
>	std::cout << logger.getLinesCount() << std::endl;
>	std::cout << logger.readNthLine(0) << std::endl;
>	std::cout << logger.readNthLine(1) << std::endl;
>}


Решение: Александр Павлинов 2022.03.03
